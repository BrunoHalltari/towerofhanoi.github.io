---
title:      HITCON 2016 - ROP
date:       2016-10-10 12:00:00
summary:    Ruby Obfuscated Programming
categories: HITCON Reversing
author:     pogliamarci
tags:
 - HITCON
 - Reversing
---

> Who doesn't like ROP? Let's try some new features introduced in 2.3.



ROP is a simple Ruby VM crackme.
We are given a file [rop.iseq]({{ site.url }}/writeups_files/rop/rop.iseq), without any other detail.

    $ file rop.iseq
    rop.iseq: data

Opening it with an hex editor, we see that it starts with `YARB`, and from its contents we guess that it is a sort of bytecode format. With Google's help, we come across Ruby's `RubyVM::InstructionSequence` class, and in particular to the `load_from_binary` method. Its purpose is "to load an iseq object from binary format String object created by #to_binary". From Ruby's sources, we see that this method, in turn, calls `iseq_ibf_load` in `compile.c`, where we can also see the structure of the binary file: it starts with the header `YARB`... so it really seems that we are dealing with serialized Ruby bytecode!

Then, we can simply load and execute this file with `RubyVM::InstructionSequence`. I had to download the Ruby interpreter from `rvm`, as the one coming with Ubuntu 16.04 had a `RUBY_PLATFORM` slightly different than the one embedded in the iseq file, and triggered a `unmatched platform` error -- likely, it was possible to change the iseq file to work around this, but it was just simpler to download the correct interpreter!

{% highlight ruby %}
iseq = nil
File.open("rop.iseq", "rb") do |file|
  iseq = RubyVM::InstructionSequence.load_from_binary(file.read)
end
iseq.eval
{% endhighlight %}

The challenge waits for the user's input; trying to enter a string, it outputs `Invalid Key @_@`. So, we need to figure out a valid input. We can also dump the disassembly:

{% highlight ruby %}
iseq.disasm
{% endhighlight %}

Unfortunately, we could not find quickly a lot of documentation about the Ruby virtual machine, or tools working with the iseq format: we had to guess the behavior of the various opcodes (it is a simple stack-based VM).

By reading the disassembly, we see that the input is split into 5 substrings having length 4 and separated by "-". Each of them has to match with the regexp `/^[0-9A-F]{4}$/` and is checked by a separate block of code. As soon as a substring does not satisfy a condition, the function `gg` is called, which outputs `"Invalid Key @_@"` and exits.

Fortunately, the bytecode contains various `trace` instructions; we made use of `set_trace_func` to have those events printed while reversing; this way, we could understand at which line of code the program was jumping to the function `gg` - and, thus, what components of our input string were correct!

Just to give an idea of how the disasm looked like, here is the disasm of the first two checks:

    0109 trace            1                                               (  42)
    0111 getlocal_OP__WC__0 2
    0113 putobject_OP_INT2FIX_O_0_C_
    0114 opt_aref         <callinfo!mid:[], argc:1, ARGS_SIMPLE>, <callcache>
    0117 putobject        16
    0119 opt_send_without_block <callinfo!mid:to_i, argc:1, ARGS_SIMPLE>, <callcache>
    0122 putobject        31337
    0124 opt_eq           <callinfo!mid:==, argc:1, ARGS_SIMPLE>, <callcache>
    0127 branchif         134
    0129 putself
    0130 opt_send_without_block <callinfo!mid:gg, argc:0, FCALL|VCALL|ARGS_SIMPLE>, <callcache>
    0133 pop
    0134 trace            1                                               (  43)
    0136 getlocal_OP__WC__0 2
    0138 putobject_OP_INT2FIX_O_1_C_
    0139 opt_aref         <callinfo!mid:[], argc:1, ARGS_SIMPLE>, <callcache>
    0142 opt_send_without_block <callinfo!mid:reverse, argc:0, ARGS_SIMPLE>, <callcache>
    0145 putstring        "FACE"
    0147 opt_eq           <callinfo!mid:==, argc:1, ARGS_SIMPLE>, <callcache>
    0150 branchif         157
    0152 putself
    0153 opt_send_without_block <callinfo!mid:gg, argc:0, FCALL|VCALL|ARGS_SIMPLE>, <callcache>
    0156 pop

(`getlocal_OP__WC__0 2` is the variable `xs`, containing the user input split at '-')

and here a rough Ruby pseudocode of the checks performed by the crackme:

{% highlight ruby %}
# 7A69
if xs[0].to_i(16) != 31337
  gg
# ECAF
if xs[1].reverse != "FACE"
  gg
if f(217, xs[2].to_i(16), 314159).to_s(28).upcase != "48D5"
  gg
# 53 * 97 = 5141
if xs[3].to_i(10).prime_division.map(:first).sort != [53, 97] 
  gg
# CA72
if xs.map |x| {
  x.to_i(16)
}.inject(:^).to_s.sha1 != "947d46f8060d9d7025cc5807ab9bf1b3b9143304"
  gg
{% endhighlight %}

For the third check, we resorted to bruteforce instead of reversing the operations performed by `f`, as the input space of a single component of the input string is very small (four digit hex numbers).
For the last check, we noticed that `947d46f8060d9d7025cc5807ab9bf1b3b9143304` is the SHA-1 of 5671, so we get the last component of the input string by just XOR-ing the first four ones with 5671. Overall, the input string is

    7A69-ECAF-1BD2-5141-CA72

which gives us the output

    Congratz! flag is hitcon{ROP = Ruby Obsecured Programming ^_<}

Here the complete Ruby code of the challenge, as we were able to reverse (by hand):
{% highlight ruby %}
require "digest"
require "prime"

def f(a, b, m)
   s = 1
   r = a
   while b != 0
      if b[0] == 1
         s = (s * r) % m
      end
      b = (b >> 1)
      r = (r * r) % m
   end
   return s
end

def gg
  print "Invalid Key @_@"
  exit
end

class String
  def sha1
    Digest::SHA1.hexdigest(self)
  end

  def enhex
    self.unpack("H*")[0]
  end

  def dehex
    [self].pack("H*")
  end

  def ^(other)
    self.bytes.map.with_index { |x, i|
        x ^ other[i % other.size].ord
    }.pack("C*")
  end
end

k = gets.chomp
xs = k.split("-")
if xs.size != 5
  gg
end
if not xs.all? { |x|
  x =~ /^[0-9A-F]{4}$/
}
  gg
end

if xs[0].to_i(16) != 31337
  gg
end
if xs[1].reverse != "FACE"
  gg
end
if f(217, xs[2].to_i(16), 314159).to_s(28).upcase != "48D5"
  gg
end
if xs[3].to_i(10).prime_division.map(&:first).sort != [53, 97]
  gg
end
if xs.map { |x|
  x.to_i(16)
}.inject(:^).to_s.sha1 != "947d46f8060d9d7025cc5807ab9bf1b3b9143304"
  gg
end

s = "bce410e85433ba94f0d832d99556f9764b220eeda7e807fe4938a5e6effa7d83c765e1795b6c26af8ad258f6"
puts "Congratz! flag is " + (s.dehex ^ k.sha1.dehex).to_s
{% endhighlight %}
