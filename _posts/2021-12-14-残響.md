---
title: X-MAS CTF - 残響 
author: Federico Villa
date: 14/12/2021
summary: How to perform a Re-Entrancy and withdraw funds from a Smart Contract.
categories: RuCTF2019 Attack/Defense
tags:
- X-MAS CTF
- Solidity
- Ethereum
- Blockchain
- Re-Entrancy
- Smart Contract
---

# Challenge: **残響**

Description: 
> ワームホールに入らないでください <br />
> nc challs.xmas.htsp.ro 8014 <br />
> http://challs.xmas.htsp.ro:8015/ <br />
> Source: https://drive.google.com/drive/folders/1IW3KfHulns8GaFBmsOYi6qRVl8tzXn9s?usp=sharing <br />

<br />

# Analizing Given Files:
Analizing the given files we can understand that:
- [**Setup.sol**](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Setup.sol), as the name suggest, is a contract that setup the blockchain environment interacting with the Iterator.sol contract and creating a new Iterator contract transferring it a value of 30 Ether.  
- [**Iterator.sol**](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Iterator.sol) is a contract with some functions that permit to donate and withdraw ethers from and to that contract and also check an address balance. Analising its code we can find out that its [witdraw](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Iterator.sol#L20-L31) function is vulnerable to a **Re-Entrancy Attack**: the variable balances isn't safety updated in the [witdraw](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Iterator.sol#L20-L31) function, so it's possible to call the function multiple times before [witdraw](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Iterator.sol#L20-L31) finishes executing. 

# Re-Entrancy Attack
This type of attack consist of calling recursively call a vulnerable function that didn't check it's own state. 
This attack was the hearth of [The DAO](https://en.wikipedia.org/wiki/The_DAO_(organization)) Hack, an hacking attack that happened in June 2016 and drained the founds of the largest smart contract of that time, that held more 150 million dollars in Ether. A more detailed description of the history of the DAO's hack can be found [here](https://coinmarketcap.com/alexandria/article/a-history-of-the-dao-hack).

# Exploit Creation
To perform this kind of attack we can create a new contract [**Reentrancy.sol**](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Reentrancy.sol), in which we write the exploit.
The contract must first call the existing Iterator.sol contract:
```solidity
    Iterator public iterator;

    constructor(address payable etherIteratorAddress) public {
        iterator = Iterator(etherIteratorAddress);
    }
```

The heart of the exploit is the function [attack](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Reentrancy.sol#L22-L26): 
```solidity
function attack() external payable {
    require(msg.value >= 1 ether);
    iterator.donate.value(1 ether)(address(this)); 
    iterator.withdraw(1 ether);
} 
```
The attack function, because of the lack of state variables or function modifiers in the withdraw function of Iterator.sol, was able to call iterator.withdraw() multiple times before it finished executing. This resulted in more refunds and essentially recovering all of the Ether in the contract.

# Transaction Sending
After the creation of [Reentrancy.sol](https://github.com/TowerofHanoi/towerofhanoi.github.io/tree/master/writeups_files/残響/Reentrancy.sol), we connect to the blockchain of the challenge with the rpc endpoint given by `nc challs.xmas.htsp.ro 8014` after selecting _launch new instance_. With that command we also receive the Setup contract address and a uuid that will then be necessary to get the flag.
Then by calling Setup.iterator we can obtain the address of the Iterator.sol contract that we can use to create the Reentrancy.sol contract by passing that address in its constructor.
Then, just by calling the Reentrancy.attack (that requires a certain amount of ether to be sent) function, we can drain the Reentrancy.sol entire balance (30 ethers) and now calling the Setup.isSolved() function we get a true value.

# Getting the flag
After we get a true value in Setup.isSolved(), we can get the flag by connecting to `nc challs.xmas.htsp.ro 8014`, selecting _get flag_ and inserting our uuid.

Turns out that the flag was:
`X-MAS{Th1s_goes_0n_and_on_and_on_and_on_and_on_and_on_and_on_and_on_and_on_and_on_and_on}`